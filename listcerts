#!/usr/bin/env python3

import datetime
import json
import subprocess
import warnings
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
from typing import Optional, Tuple, Dict, Any

import dns.resolver
from cryptography import x509
from cryptography.hazmat.backends import default_backend

CERT_DIR = Path("/etc/letsencrypt/live")
NOW = datetime.datetime.now(datetime.timezone.utc)
CACHE_FILE = Path("/home/lchiaret/.cache/cert_checker.cache.json")
CACHE_EXPIRATION = datetime.timedelta(days=30)

DNS_RESOLVER = dns.resolver.Resolver()
DNS_RESOLVER.timeout = 2.0
DNS_RESOLVER.lifetime = 2.0

def load_cache() -> Dict[str, Any]:
    if not CACHE_FILE.is_file():
        return {}
    try:
        with CACHE_FILE.open('r') as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError):
        return {}

def save_cache(cache_data: Dict[str, Any]):
    try:
        with CACHE_FILE.open('w') as f:
            json.dump(cache_data, f)
    except IOError:
        pass

def resolve_domain(domain: str) -> str:
    while True:
        try:
            answer = DNS_RESOLVER.resolve(domain, 'A')
            return answer[0].to_text()
        except Exception:
            continue

def get_certificate_data(cert_dir: Path, cache: Dict[str, Any]) -> Tuple[str, Optional[tuple]]:
    cert_name = cert_dir.name
    
    if cert_name in cache:
        entry = cache[cert_name]
        cached_at = datetime.datetime.fromisoformat(entry["timestamp"])
        if NOW - cached_at < CACHE_EXPIRATION:
            data = entry["data"]
            # Compatibilidade retroativa: 4 ou 5 valores
            if len(data) == 4:
                ip_apps, cluster, ip_api, expiry_str = data
                ip_api_int = "-"
            else:
                ip_apps, cluster, ip_api, ip_api_int, expiry_str = data
            expiry_date = datetime.datetime.fromisoformat(expiry_str)
            if expiry_date > NOW:
                return cert_name, (ip_apps, cluster, ip_api, ip_api_int, expiry_date)

    cert_path = cert_dir / "fullchain.pem"
    if not cert_path.is_file():
        return cert_name, None

    try:
        cert_data = cert_path.read_bytes()
        x509_cert = x509.load_pem_x509_certificate(cert_data, default_backend())
        expiry_date = x509_cert.not_valid_after_utc

        if expiry_date < NOW:
            subprocess.run(
                ["sudo", "certbot", "delete", "--cert-name", cert_name],
                check=False, capture_output=True
            )
            return cert_name, None

        base_name = cert_name.removeprefix("*.apps.").removeprefix("apps.")
        cluster = base_name.removesuffix(".chiaret.to") if ".chiaret.to" in base_name else base_name

        domain_to_resolve = f"resolve.apps.{base_name}"
        domain_api = f"api.{base_name}"
        domain_api_int = f"api-int.{base_name}"

        ip_apps = resolve_domain(domain_to_resolve)
        ip_api = resolve_domain(domain_api)
        ip_api_int = resolve_domain(domain_api_int)

        result = (ip_apps, cluster, ip_api, ip_api_int, expiry_date)
        return cert_name, result
    except Exception:
        return cert_name, None

def main():
    if not CERT_DIR.is_dir():
        print(f"Error: Certificate directory not found at '{CERT_DIR}'")
        return

    cache = load_cache()
    results = []
    new_cache = {}

    cert_dirs = [d for d in CERT_DIR.iterdir() if d.is_dir() and d.name.startswith("apps")]

    with warnings.catch_warnings(), ThreadPoolExecutor(max_workers=15) as executor:
        warnings.simplefilter("ignore")
        
        futures = {executor.submit(get_certificate_data, cert_dir, cache) for cert_dir in cert_dirs}

        for future in as_completed(futures):
            cert_name, data = future.result()
            if data:
                results.append(data)
                ip_apps, cluster, ip_api, ip_api_int, expiry_date = data
                new_cache[cert_name] = {
                    "timestamp": NOW.isoformat(),
                    "data": (ip_apps, cluster, ip_api, ip_api_int, expiry_date.isoformat())
                }
    
    save_cache(new_cache)

    if not results:
        print("No valid certificates found.")
        return
        
    def infra_sort_key(item):
        ip_apps, cluster, ip_api, ip_api_int, expiry_date = item
        if ip_api == ip_api_int == ip_apps:
            infra_type = "UPI Baremetal"
        elif ip_api == ip_api_int and ip_api != ip_apps:
            infra_type = "IPI"
        elif ip_api != ip_api_int and ip_api != ip_apps:
            infra_type = "UPI None"
        else:
            infra_type = "IPI"
        # UPI first (0), IPI last (1), depois pelo nome do cluster
        return (0 if infra_type.startswith("UPI") else 1, cluster.lower())

    sorted_results = sorted(results, key=infra_sort_key)

    clusters_dir = Path("/vms/clusters")
    existing_clusters = set()
    if clusters_dir.is_dir():
        existing_clusters = {d.name for d in clusters_dir.iterdir() if d.is_dir()}

    for ip_apps, cluster, ip_api, ip_api_int, expiry_date in sorted_results:
        expiry_str = expiry_date.strftime('%Y-%m-%d')
        if ip_api == ip_api_int == ip_apps:
            infra_type = "UPI Baremetal"
        elif ip_api == ip_api_int and ip_api != ip_apps:
            infra_type = "IPI"
        elif ip_api != ip_api_int and ip_api != ip_apps:
            infra_type = "UPI None"
        else:
            infra_type = "IPI"
        cluster_display = cluster + ' *' if cluster in existing_clusters else cluster
        print(f"{cluster_display: <18} | {ip_apps: <15} | {ip_api: <15} | {ip_api_int: <15} | {expiry_str} | {infra_type}")

if __name__ == "__main__":
    main()
