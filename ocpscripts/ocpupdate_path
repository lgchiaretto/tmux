#!/usr/bin/env python3

import requests
import subprocess
import json
from collections import deque
import sys

GRAPH_URL = "https://api.openshift.com/api/upgrades_info/graph"
CHANNELS = [
    "eus-4.14",
    "stable-4.15",
    "eus-4.16",
    "stable-4.17",
    "eus-4.18"
]

def fzf_select(options, header):
    try:
        result = subprocess.run(
            ["fzf-tmux", "--header", header, "--layout=reverse", "-h", "40%", "-p", "38%,30%", "--exact"],
            input="\n".join(options).encode(),
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL
        )
        return result.stdout.decode().strip()
    except FileNotFoundError:
        print("Error: fzf-tmux not found.")
        sys.exit(1)

def fzf_output_display(text, header="Upgrade Path Available"):
    tempfile = "/tmp/upgrade_path_output.txt"
    with open(tempfile, "w") as f:
        f.write(f"{text}")
    subprocess.run(
        ["tmux", "popup", "-E", "-w", "50%", "-h", "50%", f"cat {tempfile}; echo -e '\\n'; read -n 1 -s -r -p 'Press any key to close...'"]
    )

def fetch_upgrade_graph(channel):
    params = {"channel": channel, "arch": "amd64"}
    try:
        response = requests.get(GRAPH_URL, params=params)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"Error fetching graph: {e}")
        sys.exit(2)

def build_graph(data):
    nodes = [node["version"] for node in data["nodes"]]
    edges = data.get("edges", [])
    conditional_edges = data.get("conditionalEdges", [])

    graph = {}

    # Adicionar arestas regulares
    for e in edges:
        from_v = nodes[e[0]]
        to_v = nodes[e[1]]
        graph.setdefault(from_v, []).append((to_v, False, "No Risk", "No Message", "No URL"))  # False indica aresta regular

    # Adicionar arestas condicionais com riscos
    for edge_group in conditional_edges:
        for edge in edge_group.get("edges", []):
            from_v = edge.get("from")
            to_v = edge.get("to")
            risk_name = edge_group.get("risks", [{}])[0].get("name")
            risk_message = edge_group.get("risks", [{}])[0].get("message")
            risk_url = edge_group.get("risks", [{}])[0].get("url")
            graph.setdefault(from_v, []).append((to_v, True, risk_name, risk_message, risk_url))  # True indica aresta condicional

    return graph, nodes

def bfs_path(graph, from_v, to_v):
    visited = set()
    prev = {}
    edge_type = {}
    risks = {}
    messages = {}
    urls = {}
    queue = deque([from_v])
    visited.add(from_v)

    while queue:
        current = queue.popleft()
        if current == to_v:
            break
        for neighbor, is_conditional, risk_name, risk_message, risk_url in sorted(graph.get(current, []), reverse=True, key=lambda v: list(map(int, v[0].split('.')))):
            if neighbor not in visited:
                visited.add(neighbor)
                prev[neighbor] = current
                edge_type[neighbor] = is_conditional
                risks[neighbor] = risk_name
                messages[neighbor] = risk_message
                urls[neighbor] = risk_url
                queue.append(neighbor)

    if to_v not in prev and from_v != to_v:
        return None

    path = []
    v = to_v
    while v != from_v:
        path.append((v, edge_type.get(v, False), risks.get(v, "No Risk"), messages.get(v, "No Message"), urls.get(v, "No URL")))
        v = prev.get(v)
        if v is None:
            return None
    path.append((from_v, False, "No Risk", "No Message", "No URL"))
    path.reverse()
    return path

def main():
    channel = fzf_select(CHANNELS, "Select OpenShift Channel")
    if not channel:
        sys.exit(0)

    data = fetch_upgrade_graph(channel)
    graph, versions = build_graph(data)
    with open("/tmp/graph_and_versions.json", "w") as f:
        json.dump({"graph": graph, "versions": versions}, f, indent=4)

    from_version = fzf_select(versions, "Select FROM Version")
    if not from_version:
        sys.exit(0)

    to_version = fzf_select(versions, "Select TO Version")
    if not to_version:
        sys.exit(0)

    path = bfs_path(graph, from_version, to_version)
    if path:
        formatted_path = " -> ".join(f"{v}" for v, _, _, _, _ in path)
        detailed_info = "\n".join(
            f"Version: {v}\n  - Risk: {risk}\n  - Message: {message}\n  - URL: {url}"
            for v, is_conditional, risk, message, url in path if is_conditional
        )
        fzf_output_display(f"Available path: {formatted_path}\n\n{detailed_info}" if detailed_info else f"Path: {formatted_path}")
    else:
        fzf_output_display(f"No upgrade path found from {from_version} to {to_version} on channel {channel}")

if __name__ == "__main__":
    main()